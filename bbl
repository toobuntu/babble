#! /bin/ksh -p
#
# Babble (bbl): An upgrade routine for Homebrew, Mac App Store and macOS
#
# Copyright 2023 Todd Schulman <toobuntu> AT <gmail> DOT <com>
# License: GPLv3.0+
#
# Modification history
# 07-Dec-2023 T.S. Created original script
# 17-Dec-2023 T.S. Restart specified apps after upgrade
#
# NOTE: One cannot rely on Homebrew Git and the JSON API being in sync.
# If this causes issues, prefix the invocation of Babble (`bbl`) with
# HOMEBREW_NO_INSTALL_FROM_API=1 on a case-by-case basis.
# > In v4.0.0 (16-Feb-2023), Homebrew migrated from Git-cloned taps
# to JSON downloads (API) to enable significantly faster Homebrew-
# maintained tap updates. However, the API data can lag behind Git.
# Sometimes, a release is pulled and this is updated in Git, but the
# API hasn't yet synced and a download fails when trying to upgrade.
# To get the most up-to-date information, prefix the brew commands with
# HOMEBREW_NO_INSTALL_FROM_API=1 on a case-by-case basis.

# Initialization
# Exit cleanly if aborted with ⌃C.
trap 'exit 0' SIGINT

# Warn about missing dependencies
if ! command -v brew > /dev/null; then
	printf 1>&2 "%s\n" "[Babble] Warning: Homebrew is required. See https://brew.sh." "Exiting..."
	exit 2
fi

if ! command -v mas > /dev/null; then
	printf 1>&2 "%s\n" "[Babble] Warning: mas-cli is required. See https://github.com/mas-cli/mas." "Exiting..."
	exit 3
fi

# Declare variables and functions
typeset run_command next_section
# NOTE: Use escape sequences \001 and \002 (otherwise known as
# RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE) to exclude the
# counting of non-printing characters.
run_command="\001\033[33m\002-->\001\033[0m\002 [Run command] Press the Space bar to continue, or Ctrl-C to exit."
#run_command="--> [Run command] Press the Space bar to continue, or Ctrl-C to exit."
next_section="\001\033[35m\002-->\001\033[0m\002 [Next §] Press the Space bar to go to the next section, or Ctrl-C to exit."
#next_section="--> [Next §] Press the Space bar to go to the next section, or Ctrl-C to exit."
typeset -r run_command next_section

# App restart lists
# Get the app's bundle id with `osascript -e 'id of app "appname"'`
typeset -a restart_list_brew
restart_list_brew=( \
	com.intelliscapesolutions.caffeine \
	com.knollsoft.Rectangle \
	com.mowglii.ItsycalApp \
	eu.exelban.Stats \
)
typeset -r restart_list_brew

typeset -a restart_list_mas
restart_list_mas=( \
	iapp.monitorcontrol.MonitorControlLite \
	com.sindresorhus.Pandan \
)
typeset -r restart_list_mas

function waiter {
	/bin/stty -echo
	read -r -N 1 -d " " var?"$(print -e ${1:---> Press the Space bar to continue, or Ctrl-C to exit.})" < /dev/tty
	#read -r -N 1 -d " " var?"${1:---> Press the Space bar to continue, or Ctrl-C to exit.}" < /dev/tty
	/bin/stty echo
	print
}

function gen_restart_list {
	# From a list of apps known to require a restart after being upgraded,
	# generate a list of those which were running prior to the upgrade.
	#print
	printf "%s\n" "Generating an app restart list..."
	typeset -a restart_list
	unset -v -- restart_req_export
	export restart_req_export
	restart_list=("$@")
	# INSERTION: A more elegant and resource-efficient method is
	# mwa+=(com.knollsoft.Rectangle); mwa+=(com.sindresorhus.Pandan); mwa+=(eu.exelban.Stats); mwa+=(com.intelliscapesolutions.caffeine); mwab="$(for i in "${mwa[@]}"; do /usr/bin/lsappinfo info -only bundleid -app "$i" | /usr/bin/awk -F= '{gsub(/\"/,""); print $NF}'; done | sort -u)"; mwaa="$(/usr/bin/lsappinfo list | awk -F= '/bundleID/ {gsub(/\"/,""); print $NF}' | sort -u)"; comm -12 <(tr "[:space:]" "\n" <<< "${mwa[@]}") <(tr "[:space:]" "\n" <<< "$mwaa"); while IFS="" read -r line; do /usr/bin/lsappinfo info -only name "$line" | /usr/bin/awk -F= '{gsub(/\"/,""); print $NF}'; done <<< "$mwab"; unset -v mwa mwab mwaa line i;
	# Comparing mwa[@] to mwaa is more efficient than creating mwab. mwab is listed here only for its syntax.
	set -x
	for app in "${restart_list[@]}"; do
		# Arrays cannot be exported. Commas are disallowed in a
		# bundle ID. So print each element as a comma-terminated
		# string, concatenate, and export that.
		#
		# NOTE: On macOS, a bundle ID uniquely identifies a
		# single app throughout the system. The bundle ID string
		# must contain only alphanumeric characters (A–Z, a–z,
		# and 0–9), hyphens (-), and periods (.). Bundle IDs are
		# case-insensitive.
		# https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundleidentifier
		#
		# NOTE: It is common to use NUL-terminated strings, but
		# NUL cannot be stored in a variable because it is the
		# character used to delimit the end of a variable. (One
		# can use any binary data, including NUL, in pipes and
		# files.) So use a temporary file (which can contain
		# NUL) or base64 encode the data in the variable.
		# Exporting a base64 encoded variable did not work as
		# intended except with openssl. Using a temp file is
		# not necessary because bundle IDs cannot contain
		# commas. Therefore, use comma-separated values.
		#
		# Print the ASCII NUL character (character code 0) via
		# printf "%c" 0 or printf "\000" or printf "%b" "\000",
		# and use it like find ... -print0 | xargs -0.
		#
		# macOS 14 Sonoma comes with /usr/bin/openssl,
		# /usr/bin/base64 and /usr/bin/uu{en,de}code, which can
		# do base64 encoding and decoding, but only uuencode is
		# POSIX. That said, openssl is used in Babble.
		# openssl base64 -A | openssl base64 -d -a -A, or
		# openssl enc -base64 -A | openssl enc -base64 -d -a -A
		# base64 | base64 -d
		# uuencode -mr - | uudecode -mrp
		# DEBUG: Check for '\0' (nul) by piping to od -acAn.
		restart_req_export+="$(/usr/bin/lsappinfo info -only bundleid -app "$app" | /usr/bin/awk -F= '{gsub(/\"/,"",$2); printf( "%s%c", $2, 0 )}' | /usr/bin/openssl base64)"
		#restart_req_export+="$(/usr/bin/lsappinfo info -only bundleid -app "$app" | /usr/bin/awk -F= '{gsub(/\"/,"",$2); printf( "%s,", $2 )}')"
	done
	#restart_req_export="$(printf "%s" "$restart_req_list" | uuencode -m -)"
	#print "DEBUG:"
	#print "restart_req_export=$restart_req_export"
	#<<< "${restart_req_list}" | od -acAn
	#print "$restart_req_export" | /usr/bin/openssl base64 -d -v -a -A| od -acAn
	#waiter "DEBUG"
	#{ set +x; }
	/usr/bin/openssl base64 -d -a -A <<< "$restart_req_export" | /usr/bin/xargs -0 -I % /usr/bin/lsappinfo info -only name -app % | /usr/bin/awk -F= '{gsub(/\"/,"",$2); print($2)}'
	#print "${restart_req_export}" | /usr/bin/tr "," "\0" | /usr/bin/xargs -0 -I % /usr/bin/lsappinfo info -only name -app % | /usr/bin/awk -F= '{gsub(/\"/,"",$2); print($2)}'
	print

	# Unused #2
	# Big thanks to William 'talkingmoose' Smith for this way of parsing lsappinfo
	# restart_apps=("$(/usr/bin/lsappinfo list | /usr/bin/awk -F '\\) "|" ASN' 'NF > 1 && tolower($2) ~ /stats/ {print $2}')")
	# Unused #1
	# restart_apps="$(/usr/bin/lsappinfo info -app eu.exelban.Stats | /usr/bin/awk '$1 == "pid" {print $3}')"; test -n "$restart_apps" && open -b eu.exelban.Stats || :
}

function restarter {
	waiter "$run_command"
	# Restart apps from the saved list
	typeset -a restart_req
	/usr/bin/openssl base64 -d -a -A <<< "$restart_req_export" | tr "\0" "\n" | \
	#printf "%s" "$restart_req_export" | /usr/bin/tr "\0" "\n" | \
	#printf "%s" "$restart_req_export" | /usr/bin/tr "," "\n" | \
		while IFS="" read -r line; do
			restart_req+=("$line")
		done
	# NOTE: rr=( $(...) ) was abandoned in favor of shellcheck's
	# suggestion to use while read; do; done.
	# shellcheck disable=SC2207
	#restart_req=( $(printf "%s" "$restart_req_export" | /usr/bin/tr "," "\n") )
	unset -v -- restart_req_export;

	# Unset any empty array elements
	for i in "${!restart_req[@]}"; do
		test -z "${restart_req[$i]}" && \
			unset -v -- restart_req[$i];
	done

	# No apps on the watchlist were running prior to the upgrade
	if test "${#restart_req[@]}" -eq 0; then
		print
		printf 1>&2 "%s\n" "No apps need to be restarted..."
		return
	fi

	# No apps to restart; still running after upgrade
	typeset -a restart_list_still_running
	printf "%s\0" "${restart_req[@]}" | /usr/bin/xargs -0 -I % /usr/bin/lsappinfo info -only displayname -app % | /usr/bin/awk -F= '{gsub(/\"/,"",$2); print $2}' | \
		while IFS="" read -r line; do
			restart_list_still_running=+=("$line")
		done
	# Unset any empty array elements
	for i in "${!restart_list_still_running[@]}"; do
		test -z "${restart_list_still_running[$i]}" && \
			unset -v -- restart_list_still_running[$i];
	done
	# DEBUG: printf "%s\n" "restart_list_still_running=" "${restart_list_still_running[@]}"
	# Test if the running apps list decreased in count post-upgrade
	if test "${#restart_list_still_running[@]}" -eq "${#restart_req[@]}"; then
		print
		printf 1>&2 "%s\n" "No apps need to be restarted..."
		return
	fi

	# There is something to restart
	print
	printf "%s\n" "Restarting apps from the restart list..."
	set -x
	for app in "${restart_req[@]}"; do
		if test -z "$(/usr/bin/lsappinfo info -only pid -app "$app")"; then
			/usr/bin/open -b "$app"
		fi
	done
	{ set +x; }
}

# Intro
/usr/bin/tput clear
printf "%s\n" "-----------------------------------------------------------------------"
printf "%s\n" "| ⨀ Babble: An upgrade routine for Homebrew, Mac App Store and macOS. |"
printf "%s\n" "-----------------------------------------------------------------------"
print

# Homebrew
printf "%s\n" "Updating Homebrew -- The Missing Package Manager for macOS..." 'Would run `brew update`, and then `brew desc --eval-all` for any new packages'
waiter "$run_command"
set -x
brew update 2>&1 | /usr/bin/tee "${TMPDIR:-/tmp/}bup.out"
{ set +x; }
#set -x
/usr/bin/awk '/==> New/{print(""); exit}' "${TMPDIR:-/tmp/}bup.out"
# When f == 1, the "1" is a condition that is always true, and will
# trigger the default action which is to print the current line.
/usr/bin/awk '/==> New/{f = 1; next} /==> (Outdated|Renamed|Deleted|Modified)/{f = 0} /^You have/{f = 0} /^Already up-to-date.$/{f = 0}; f' "${TMPDIR:-/tmp/}bup.out" | /usr/bin/xargs -J % brew desc --eval-all %
#{ set +x; }
/bin/rm -f "${TMPDIR:-/tmp/}bup.out"
waiter "$next_section"

print
printf "%s\n" "Listing installed packages which are outdated..." 'Would run `brew outdated`'
# By default, version information is displayed in interactive shells, and suppressed otherwise. Use --verbose to include detailed version information.
waiter "$run_command"
set -x
brew outdated --greedy-auto-updates --fetch-HEAD --verbose
{ set +x; }
waiter "$next_section"

print
printf "%s\n" "Upgrading outdated packages..." 'Would run `brew upgrade`'
waiter "$run_command"

gen_restart_list "${restart_list_brew[@]}"

set -x
brew upgrade --greedy-auto-updates --fetch-HEAD --no-quarantine --display-times
{ set +x; }

restarter
waiter "$next_section"


# Mac App Store
print
printf "%s\n" "Listing outdated Mac App Store apps..." 'Would run `mas outdated`'
waiter "$run_command"
typeset outie
outie="$(set -x; mas outdated; { set +x; })"

if test -n "$outie"; then
	printf "%s\n" "$outie"
	waiter "$next_section"
	print
	printf "%s\n" "Upgrading outdated Mac App Store apps..." 'Would run `mas upgrade`'
	waiter "$run_command"

	gen_restart_list "${restart_list_mas[@]}"

	set -x
	mas upgrade
	{ set +x; }

	restarter
fi
waiter "$next_section"


# macOS
print
printf "%s\n" "Listing all available updates to macOS..." 'Would run `softwareupdate --list`'
waiter "$run_command"
set -x
/usr/sbin/softwareupdate --list 2> "${TMPDIR:-/tmp/}su.err"
{ set +x; }
test -f "${TMPDIR:-/tmp/}su.err" && /bin/cat "${TMPDIR:-/tmp/}su.err" || :
#waiter "$next_section"

if ! /usr/bin/grep --quiet --fixed-string "No new software available." "${TMPDIR:-/tmp/}su.err"; then
	/bin/rm -f "${TMPDIR:-/tmp/}su.err"
	waiter "$next_section"
	print
	printf "%s\n" "Installing all available updates to macOS..." "A system restart may occur if required to complete installation." 'Would run `sudo softwareupdate --install`'
	waiter "$run_command"
	set -x
	/usr/bin/sudo /usr/sbin/softwareupdate --all --install --restart --no-scan
	{ set +x; }
fi

/bin/rm -f "${TMPDIR:-/tmp/}su.err"


# Conclusion
print
printf "\001\033[36m\002%s\001\033[0m\002 %s\n" "⨀" "[Babble] All finished! Exiting..."
#printf "\n%s\n" "[🔄 Babble] All finished! Exiting..."
